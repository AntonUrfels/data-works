---
title: "1_R_data_cleaning"
author: "Hari Sankar Nayak"
date: "2024-03-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setting the working directory

```{r}
getwd()
#setwd("C:/Users/hsn28/Downloads/All_postdoc/Rice_yield_gap_all/dataverse_files_2017r")
#setwd("C:/Users/hsn28/Desktop/R_training")
library(readxl)
```

# Reading the data

```{r}

survey <- read.csv("../data/CSISA_IND_LDS_Rice_2017_Data.csv")
#Import using GUI. 

survey_market = read.csv("../data/Market_data.csv")
survey_market = read.csv("../data/Market_data.csv",skip = 1)
```

# Remove duplicate rows

```{r}
#calculate number of rows from each data frame
nrow(survey)
nrow(survey_market)

#calculate number of UNIQUE IDs
length(unique(survey_market$meta.instanceID))
length(unique(survey$meta.instanceID))

library(tidyverse)
library(dplyr)
dmost <- survey %>% distinct(meta.instanceID, .keep_all = TRUE)
dmarket <- survey_market %>% distinct(meta.instanceID, .keep_all = TRUE)
### Note distinct comes from dplyr package, there are other functions which can do the same thing. 
```

# Lets merge both data frames

```{r}
merged_data <- merge(dmost, dmarket, by.x = "meta.instanceID", by.y = "meta.instanceID")
head(merged_data)
```

# Lets have simple variable names

Here, we want to make sure our life is easy - and that future users can more readily work with the data. Also, variable names are crucial for automation. If you always use the same variable names - then you can recycle your scripts for analysis. You will see that later.

So we strive for simple, meaningful and short names. Most importantly - be consistent. I like to use underscores for variable_names (called 'snake case'). Some people like capitals for variableNames (called 'camel case'). Try to be clean and simple.

Here are some good examples:

-   yield; n_rate; production_plot; production_farm; irrigation_number

Here are some bad examples:

-   12013_YTH; YTHLP; NP2024;

Sometimes surveys collect a lot of data as researchers might want to explore very specific topics. At the same time - we collect more and more data and want to ensure that the common and most important variables are always collected and managed the same way. Then we can easily merged them in the future and use in united analysis. So when starting, try to stay focused and priortize the most important ones first.The most important variables for agronomic surveys are normally:

General ones:

-   Location: Administrative units at level 0(country), 2(province/state),3(district),4(village,municipality)

-   GPS Coordinates ideally of each plot; sometimes it is of household: latitude, longitude

-   Landholding info: plot number, area of total farm, area of largest plot

-   Household info: number of people; sex of household head; age of household head; education;

-   Cultivation options: crop; season; previous crop;

Then for the production practices, you can think chronologically from planting to harvest and key aspect like fertilizer, irrigation, weeds, pests, disease,:

-   Planting: planting date; seed rate; variety; crop establishment method (e.g. DSR, TPR); seedling age; etc.

-    Fertilizer: use of farm yard manure; fertilizer type; basal application amount; top dressing amounts;

-   Irrigation: number of irrigations; number of drainages; irrigation source; pump use; energy source;

-   Weed/Pest/Disease: most common weeds; number of weeding times; number of spraying;

-   Harvest: harvest date; harvest method; production amount plot; production amount whole farm; price received; percentage sold to market;

Importantly! Do not calculate variables at this step. Just focus on making the existing variables manageable.

At the next step we will then calculate key variables. Commonly calculated variables include:

-   Yield (t per ha); N rate (kg per ha); revenue (USD per ha); duration (days);

For each calculated variable it is best to have it's own section. Sometimes it happens that we make a mistake in the calculations - it is then easy to adjust this.

Tasks: Take a look at these scripts. What do they do?

1.  Can you make your life easier by further improving the variable names?
2.  Focus on just a few that you are interested in.

```{r}
#Rename a single column 
names(merged_data)[names(merged_data) == "C-q305_cropLargestArea"] <- 'cropLargestArea'
#Rename with consisten Pattern 

#j=strsplit(colnames(merged_data), "_")
#df <-data.frame(t(as.data.frame.list(j)))
#names(merged_data) = df$X2

#cor_names = names(merged_data)
#cor_names
#write.csv(cor_names,"cor_names.csv")
#write.csv(names(merged_data), "old_names.csv")
names = read.csv("../data/cor_names.csv")
names(merged_data) <- names$new

which(duplicated(names(merged_data)))
merged_data[,which(duplicated(names(merged_data)))] = NULL
which(duplicated(names(merged_data)))
```

# Structure of data, coverting to other type

When we read data, R tries to detect the type. But sometimes this does not work perfectly. Normally this is the case when there are mixed data types. Or when NA (not available) values are not coded consistently. Or when there's just a type.

Ideally, we should constrain our data types during data collection - so that numeric can only enter numbers. Text can only choose from drop down. But mistakes, happen. And we need to adjust these here.

```{r}
str(merged_data)
class(merged_data)
merged_data$cropSeedAmt <- as.numeric(merged_data$cropSeedAmt)
merged_data$basalDAP    <- as.numeric(merged_data$basalDAP)
merged_data$basalUrea   <- as.numeric(merged_data$basalUrea)
merged_data[,c("varName","droughtSeverity")] = sapply(merged_data[,c("varName","droughtSeverity")], as.factor)
```

# Variety name

Now that we have a rather clean dataset, let's explore some of the variables. Let's start with varieties. With varieties, we often find many names that apply for the same variety. Also, often data collectors enter varieties with typos. So it's important to spend some time here and use our knowledge to adjust these. Please do not edit the data directly in excel. But you can use R scripts to replace or correct misspellings. This ensures full integrity so that anyone can later see what you did with the dataset and perhaps identify ways to improve it.

We can start by getting an overview of all the variety names using the table functions. We need to then work through these one by one to ensure they are all correct and we don't have misspellings.

```{r}
table(merged_data$varName)
var_name <- data.frame(table(merged_data$varName))
var_name <- var_name %>% arrange(desc(Freq))
err_7029 <- c("MTU_7029", "Mansuri_MTU7029", "MiniMansuri_MTU7029", "MTU7029", "Golden_MTU7029", "MTU7026")
err_pooja <- c("OtherPooja", "OtherPuja")
err_sonam <- c("Sonam", "Swanam")

merged_data$varName <- ifelse(merged_data$varName %in% err_7029, "MTU_7029", merged_data$varName)
merged_data$varName <- ifelse(merged_data$varName %in% err_pooja, "Pooja", merged_data$varName)
merged_data$varName <- ifelse(merged_data$varName %in% err_sonam, "Sonam", merged_data$varName)

dominant_variety <- var_name %>% filter(Freq>30) 
merged_data$varName <- ifelse(merged_data$varName %in% dominant_variety$Var1, merged_data$varName, "Other")

pie(dominant_variety$Freq, labels = dominant_variety$Var1, cex = 0.5)

ggplot(dominant_variety, aes(x="", y=Freq, fill=Var1)) +
  geom_bar(stat="identity", width=1, color = "white") +
  coord_polar("y", start=0)+theme_bw()
#(https://r-graph-gallery.com/piechart-ggplot2.html)

ggplot(dominant_variety, aes(x=Var1, y=Freq, fill=Var1)) +
  geom_bar(stat = "identity",width=1, color = "white")+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+theme(legend.position="top")

ggplot(dominant_variety, aes(x=Var1, y=Freq)) +
  geom_bar(stat = "identity",width=1, color = "white", aes(fill = as.factor(Var1)))+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+theme(legend.position="top")#+scale_fill_brewer(palette = "Greens",direction = -1)

##How yield varies accoridng to variety 
boxplot(merged_data$`L-tonPerHectare`~merged_data$varName)
```

# All fertilizer - calculate fert_rates

Now let's calculate fertilizer rates. For this, we need to calculate the full amount of each fertilizer applied. E.g. total_dap, total_npk. We then need to use the NPK ratings, to calculate the total N, P, and K applies by e.g. calculating n_total (total_npk \* n_rating_npk) + (total_urea \* n_rating_urea). We then calculate n rate by adjusting for plot size and the land unit size, if local land unit (llu) were used: n_rate = n_total / (plot_size \* llu_ha).

```{r}
library("dplyr")
str(merged_data$basalDAP)
summary(merged_data$basalDAP)

merged_data <- merged_data %>%
  mutate(basalDAP = coalesce(basalDAP, 0),
         basalBoron = coalesce(basalBoron, 0),
         basalUrea = coalesce(basalUrea, 0),
         basalNPK = coalesce(basalNPK, 0),
         basalNPKS = coalesce(basalNPKS, 0),
         basalMoP = coalesce(basalMoP, 0),
         basalTSP = coalesce(basalTSP, 0),
         basalSSP = coalesce(basalSSP, 0), 
         basalZnSO4 = coalesce(basalZnSO4, 0), 
         `1tdDAP`= coalesce(`1tdDAP`, 0), 
         `1tdNPK`= coalesce(`1tdNPK`, 0), 
         `1tdNPKS`= coalesce(`1tdNPKS`, 0), 
         `1tdUrea`= coalesce(`1tdUrea`,0),
         `1tdMoP` = coalesce(`1tdMoP`,0), 
         `1tdSSP` = coalesce(`1tdSSP`, 0),
         `1tdTSP` = coalesce(`1tdTSP`,0),
         `1tdZnSO4` = coalesce(`1tdZnSO4`,0), 
         `1tdBoron` = coalesce(`1tdBoron`,0),
         `2tdDAP`= coalesce(`2tdDAP`, 0), 
         `2tdNPK`= coalesce(`2tdNPK`, 0), 
         `2tdNPKS`= coalesce(`2tdNPKS`, 0), 
         `2tdUrea`= coalesce(`2tdUrea`,0),
         `2tdMoP` = coalesce(`2tdMoP`,0), 
         `2tdSSP` = coalesce(`2tdSSP`, 0),
         `2tdTSP` = coalesce(`2tdTSP`,0),
         `2tdZnSO4` = coalesce(`2tdZnSO4`,0), 
         `3tdDAP`= coalesce(`3tdDAP`, 0), 
         `3tdNPK`= coalesce(`3tdNPK`, 0), 
         `3tdNPKS`= coalesce(`3tdNPKS`, 0), 
         `3tdUrea`= coalesce(`3tdUrea`,0),
         `3tdMoP` = coalesce(`3tdMoP`,0), 
         `3tdSSP` = coalesce(`3tdSSP`, 0),
         `3tdZnSO4` = coalesce(`3tdZnSO4`,0), 
         `3tdBoron` = coalesce(`3tdBoron`,0))

```

# NPK grades

```{r}
table(merged_data$gradeNPK)

err_28_28_0 <- c("Other28-28", "Other28-28-0","Other28.28","Other28.28.0","Other28:28:0","Other27-28-0")

merged_data$gradeNPK <- ifelse(merged_data$gradeNPK %in% err_28_28_0, "28_28_0", merged_data$gradeNPK)

err_20_20_13 <- c("Other20-20--13","Other20-20-13","Other20 - 20 -013")

merged_data$gradeNPK <- ifelse(merged_data$gradeNPK %in% err_20_20_13, "20_20_13", merged_data$gradeNPK)

merged_data$gradeNPK <- ifelse(merged_data$gradeNPK == "Other18.46" | merged_data$gradeNPK == "Other18 18 46", "18_18_46", merged_data$gradeNPK)

merged_data$gradeNPK <- ifelse(merged_data$gradeNPK == "Other14_35_14", "14_35_14", merged_data$gradeNPK)

merged_data$gradeNPK = ifelse(merged_data$gradeNPK == "10_26_26" | merged_data$gradeNPK == "12_32_16" | merged_data$gradeNPK == "14_35_14" | merged_data$gradeNPK == "17_17_17"| merged_data$gradeNPK == "18_18_46" | merged_data$gradeNPK == "20_20_13" | merged_data$gradeNPK == "28_28_0", merged_data$gradeNPK, 0)
```

# Separate to NPK grades

```{r}
cols = c("N_grade", "P_grade", "K_grade")
merged_data <- merged_data %>% separate(gradeNPK, sep = "_", into = cols, remove = FALSE)
merged_data$N_grade = as.numeric(merged_data$N_grade)
merged_data$P_grade = as.numeric(merged_data$P_grade)
merged_data$K_grade = as.numeric(merged_data$K_grade)
summary(is.na(merged_data$N_grade))
```

# Change all these NA to 0 for further arithmetic

```{r}
merged_data$N_grade = coalesce(merged_data$N_grade, 0)
merged_data <- merged_data %>% mutate(N_grade = coalesce(N_grade,0), 
                                     P_grade = coalesce(P_grade,0),
                                     K_grade = coalesce(K_grade,0))

```

# Calculate N,P,K, rates

This can now get messy - you welcome to make it easier to read. See the second calculation as an example. Always strive for simple code that easy to read :).

A good way to make this easier is by making short calculations across multiple lines.

Also, look out for some style improvements that you can make - e.g. can you identify some assignment operations where we used the equal sign, which works - but is not best practice.

```{r}
merged_data$total_N <- merged_data$basalDAP * 0.18 + merged_data$basalNPK *
  (merged_data$N_grade / 100) + merged_data$basalUrea * 0.46 + merged_data$`1tdUrea` *
  0.46 + merged_data$`2tdUrea` * 0.46 + merged_data$`3tdUrea` * 0.46 + merged_data$`1tdDAP` *
  0.18 + merged_data$`1tdNPK` * (merged_data$N_grade / 100) + merged_data$`2tdDAP` *
  0.18 + merged_data$`2tdNPK` * (merged_data$N_grade / 100) + merged_data$`3tdDAP` *
  0.18 + merged_data$`3tdNPK` * (merged_data$N_grade / 100)

# try to keep short lines and seperate the code logically. 
# td stands for top dressing number 1,2,3.
merged_data$total_p <-
  merged_data$basalDAP * 0.46 +
  merged_data$basalNPK * (merged_data$P_grade /100) +
  merged_data$`1tdDAP` * 0.46 +
  merged_data$`2tdDAP` * 0.46 +
  merged_data$`3tdDAP` * 0.46 +
  merged_data$`1tdNPK` * (merged_data$P_grade / 100) +
  merged_data$`2tdNPK` *  (merged_data$P_grade / 100) +
  merged_data$basalSSP * 0.145 +
  merged_data$basalTSP * 0.45 +
  merged_data$`1tdSSP` * 0.145 +
  merged_data$`2tdSSP` * 0.145 +
  merged_data$`3tdSSP` * 0.145 +
  merged_data$`1tdTSP` * 0.45 +
  merged_data$`2tdTSP` * 0.45

merged_data$total_K = (
  merged_data$basalMoP + merged_data$`1tdMoP` + merged_data$`2tdMoP` + merged_data$`3tdMoP`
) * 0.60 + (
  merged_data$basalNPK  + merged_data$`1tdNPK` + merged_data$`2tdNPK` + merged_data$`3tdNPK`
) * (merged_data$K_grade / 100)

merged_data$total_zn = (
  merged_data$basalZnSO4 + merged_data$`1tdZnSO4` + merged_data$`2tdZnSO4` +
    merged_data$`3tdZnSO4`
) * 0.20

merged_data$total_B  = (merged_data$basalBoron + merged_data$`1tdBoron` + merged_data$`3tdBoron`) *
  0.10

merged_data$total_N_ha = merged_data$total_N / merged_data$cropLarestAreaAcre *
  2.5
#merged_data$total_N_ha = ifelse(merged_data$total_N_ha > 550, NA, merged_data$total_N_ha)
merged_data$total_p_ha = merged_data$total_p / merged_data$cropLarestAreaAcre *
  2.5
merged_data$total_K_ha = merged_data$total_K / merged_data$cropLarestAreaAcre *
  2.5
merged_data$total_Zn_ha = merged_data$total_zn / merged_data$cropLarestAreaAcre *
  2.5
merged_data$total_B_ha = merged_data$total_B / merged_data$cropLarestAreaAcre *
  2.5
merged_data$seed_ha    = merged_data$cropSeedAmt / merged_data$cropLarestAreaAcre *
  2.5

#Corecting the N rates per ha.
boxplot(merged_data$total_N_ha)
k = boxplot(merged_data$total_N_ha)

merged_data$total_N_ha = ifelse(merged_data$total_N_ha > 300, 200, merged_data$total_N_ha)
```

# More automatic way..

Explain a bit more.

```{r}
summary(merged_data$total_N_ha)
hist(merged_data$total_N_ha)
N_err = boxplot(merged_data$total_N_ha)

merged_data$total_N_ha  = ifelse(merged_data$total_N_ha>N_err$stats[5,1],N_err$stats[5,1],merged_data$basalDAP) 
```

# Summary of N rate by variety types (Aggregate use, multiple category, multiple default function)

```{r}
mean_N <- aggregate(merged_data[,c("total_N_ha")], list(merged_data$varName), mean, na.rm = TRUE) 
min_N <- aggregate(merged_data[,c("total_N_ha")], list(merged_data$varName), min, na.rm = TRUE) 
max_N <- aggregate(merged_data[,c("total_N_ha")], list(merged_data$varName), max, na.rm = TRUE) 

N_use <- cbind(mean_N, min_N, max_N)
N_use <- N_use[,c(1,2,4,6)]
names(N_use) <- c("Var","Mean_N","Min_N", "Max_N")

aggregate(total_N_ha ~ droughtSeverity+varName, data = merged_data, FUN = function(x)c(mean = mean(x), min = min(x),max = max(x)))


aggregate(total_N_ha ~ droughtSeverity+varName, data = merged_data, FUN = function(x)c(mean = mean(x), min = min(x),max = max(x)))   
```

# Dealing with Dates (Pattern matching, replacements, Date format, Julian days converison)

R can handle data with it's own class. For this we use the as.Date() function. There is a global standard for defining dates [strptime](https://linux.die.net/man/3/strptime) -\> String (i.e. letters, words, not numbers) representation of time. What is in R a character vector, is often called a string in other programming languages.

So when you convert a character vector to a Date - then you can use this format it represent typical data components with % and letters. E.g. **%Y** is The Year including century. So a date with "1998-05-30" would be "%Y-%m-%d". If we use e.g. month name like "1998-May-30" then it would be "%Y-%b-%d".

The date format holds dates as number of days since a defined starting date. Often that is "1980-01-01".

A lot of times - we want to just calculate number of days - and thus use day of year for dates. However, if e.g. a season stretched across two calendar years then it can cause issues. So be careful on how you use and define dates.

The lubridate package holds many convenience functions for working with dates. For example the yday() function calculates the day of year for us.

For cleaning - we basically want to bring the columns into the ISO standard "yyyy-mm-dd". In this format - it can easily be read and covnerted as this is the accepted standard. If our data does not have that format, we can convert it to this format using R through the above mentioned methods.

```{r}
library(lubridate)
merged_data$harvestDate1 = merged_data$harvestDate

merged_data$harvestDate1 = gsub( "/", "-", merged_data$harvestDate1, ignore.case = T)
merged_data$harvestDate1 = gsub("-12-2018", "-12-2017",merged_data$harvestDate1, ignore.case = T)
table(merged_data$harvestDate1)
str(merged_data$harvestDate1)
merged_data$harvestDate1 = as.Date(merged_data$harvestDate1, format = "%d-%m-%Y")

#Convert to Julian Days 
merged_data$hd_jul <- as.POSIXlt(merged_data$harvestDate1)$yday
hist(merged_data$hd_jul)
merged_data$hd_jul <- ifelse(merged_data$hd_jul < 35, merged_data$hd_jul + 365, merged_data$hd_jul)


merged_data$seedingSowingTransDate1 <- merged_data$seedingSowingTransDate

table(merged_data$seedingSowingTransDate1)
merged_data$seedingSowingTransDate1 <- gsub( "/", "-", merged_data$seedingSowingTransDate1, ignore.case = T)
str(merged_data$seedingSowingTransDate1)
merged_data$seedingSowingTransDate1 <- as.Date(merged_data$seedingSowingTransDate1, format = "%d-%m-%Y")

merged_data$sow_jul1 <- as.POSIXlt(merged_data$seedingSowingTransDate1)$yday

merged_data$sow_jul  <- yday(as.Date(merged_data$seedingSowingTransDate1,"%d-%m-%Y"))

hist(merged_data$sow_jul)
merged_data$dur <- merged_data$hd_jul - merged_data$sow_jul

boxplot(merged_data$dur)

merged_data$dur <- ifelse(merged_data$dur < 50, mean(merged_data$dur,na.rm = T), merged_data$dur)

which(merged_data$dur < 80)
```

#Subset based on some condition for particular variable

```{r}
table(merged_data$varType)
# Subset for non basmati and Unknown
merged_data1 = merged_data %>% dplyr::filter( varType %in% c("Hybrid","Improved","Local"))

merged_data2 = subset(merged_data, varType == "Hybrid" | varType == "Improved" | varType == "Local")
```

# Subset some of the variables

```{r}
merged_data3 = subset(merged_data, select=c("varType","total_N_ha"))
merged_data3 = subset(merged_data, select = collectionDate:state)

merged_data3 = merged_data[,grep("Urea",colnames(merged_data))]
merged_data3 = merged_data[,grep("Urea|DAP",colnames(merged_data))]

vect = c("Urea","DAP","NPK")
merged_data3 = merged_data[,grep(paste0(vect, collapse = "|", sep = ""), colnames(merged_data))]
```

# Changing some features

Sometimes, we have many categories and do not want to use them all in our analysis. For example, we find that there are only vary few cases of a specific class - in that case we can change that value. There are many ways to do it. Ifelse, is a common way to evaluate and replace. You can also use subsetting.

```{r}
table(merged_data$drainClass)
merged_data$drainClass <- ifelse(merged_data$drainClass == "VeryLowLand", "LowLand", merged_data$drainClass)
#below we use subsetting, by first selecting the drainClass variable, 
#then identifying the indexes where drainage class is VeryLowLand and
#assigning the value LowLand to all the selected values

merged_data$drainClass[merged_data$drainClass == "VeryLowLand"] <- "LowLand"


table(merged_data$cropResiduePcnt)
str(merged_data$cropResiduePcnt)
merged_data$cropResiduePcnt <- as.numeric(merged_data$cropResiduePcnt)
merged_data$residu_retain <- ifelse(merged_data$cropResiduePcnt == 0, "No", "Yes")


#table(data$prevCrop)
#data$prevCrop    <- ifelse(data$prevCrop == "Wheat" | data$prevCrop == "Fallow", data$prevCrop, "Other")
```
